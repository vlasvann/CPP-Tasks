# CPP-Tasks

# Генератор псведослучайных чисел

В рамках задания были реализованы два генератора псевдослучайных чисел, а также InputIterator, совместимый с функциями STL.

SimplePNG - класс, хранящий состояние генератора чисел типа double, является функтором. Генератор детерминированный, при одинаковых параметрах и seed выдает одну и ту же последовательность. Метод reset() возвращает генератор в исходную точку (к изначальному seed, который передали либо в конструкторе либо в reset(double)). Метод begin() возвращает итератор начала, а end(double) создает конечный итератор. 

IntegerLCG - класс, представляющий линейный конгруэнтный генератор, соответсвующий требованиям UniformRandomBitGenerator.
Параметры генератора являются параметрами шаблона. Данные значения являются характеристиками конкретной разновидности LCG, поэтому они публичные. Данный генератор работает с любыми беззнаковыми целыми типами. Для того, чтобы избежать переполнения используется метод [Шраге](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/bits/random.tcc#L49-L78).
Засчет соответствия требованиям [URBG](https://en.cppreference.com/w/cpp/numeric/random/UniformRandomBitGenerator.html), генератор используется в std::uniform_int_distribution, std::uniform_real_distribution -> в shuffle. 

InputIterator - класс, представляющий собой специализированный итератор ввода (input iterator), предназначенный для последовательного извлечения значений из генератора случайных чисел. Данный итератор используется в алгоритмах стандартной библиотеки, таких как std::copy, std::for_each, и др. Он предоставляет два вида состояния: начальный итератор (begin), который связан с конкретным RNG и конечный итератор (end), который не связан с генератором, но содержит параметр (eps), задающий критерий остановки. Перебор происходит до тех пор, пока текущие сгенерированные значения не приблизятся к начальному. Класс параметризуется типом генератора, содержит нужные псевдонимы типов, соблюдает требования стандартного концепта InputIterator. Здесь ключевая особенность это сравнение. Оно выполняется по значениям генератора и критерию остановки. Первое значение специально исключается (через флаг _first_step).

# Операции с индексной маской

В рамках задания был реализован класс Mask, представляющий индексную маску. Данный класс поддерживает операции фильтрации контейнеров, преобразования элементов по маске, а также метод, совмещающий две операции одновременно.

Используемые концепты:
1. SliceableByIndex
   описывает контейнеры, у которых есть метод at(i), resize(i), size(i). Позволяет реализовать быструю фильтрацию без удаления элементов по одному, за один проход, перезаписывая нужные элементы в начало и уменьшая размер контейнера.
2. EraseIfCompatible
   описывает контейнеры, для которых доступна операция std::erase_if.
3. Transformable
   описывает пару контейнер + функция, для котрых можно скопировать контейнер, вызвать функцию на элементе контейнера, элементы не константные, результат функции можно присвоить обратно в элемент контейнера.

Сама маска хранится в std::array<bool, N>, где N - размер маски, array constexpr - совместим. Конструктор маски шаблонный, принимает пакет параметров, на этапе комплияции проверят количество аргументов, проверяет, что они целочисленные, а также проверяет значения, при использовании в constexpr контексте - на этапе комплияции, иначе - в рантайме. Реализованы два метода для доступа к индексам. Первая версия at(i) может работать как в runtime, так и в constexpr контексте. Начиная с 20 стандарта, throw может находиться внутри constexpr функции, но не может быть выполнен в constexpr вычислении. Стандарт гарантирует отбрасывание операнда тернарного оператора. Пример такой реализации можно увидеть [здесь](https://github.com/gcc-mirror/gcc/blob/master/libstdc%2B%2B-v3/include/std/array#L224-L244). А также есть версия с compile-time индексом, где индекс передается в качестве параметра шаблона. Поле __data_ оставлено публичным, поскольку доступность всех нестатических данных является требованием для использования класса Mask<N> в качестве NTTP. 

Метод slice(Container &container):
1. Для контейнеров, удовлетворяющих концепту SliceableByIndex.
Алгоритм выполняет фильтрацию контейнера in-place: последовательно проходит по контейнеру, сохраняя только элементы, соответствующие истинным значениям маски, сдвигая их к началу контейнера с использованием семантики перемещения для избежания лишних копирований. Переменная write отслеживает позицию для вставки сохраненных элементов, а после завершения фильтрации контейнер обрезается до размера оставшихся элементов через resize.

2. Для контейнеров, совместимых с std::erase_if, но не удовлетврояющих концепту EraseIfCompatible.
Алгоритм последовательно проверяет каждый элемент контейнера на соответствие булевой маске: элементы, соответствующие ложным значениям маски, удаляются из контейнера.

Метод transform(const Container &c, Func f):
Возвращает копию переданного контейнера, в котором функция f применяется только к элементам, соответсвующим true в маске. Метод доступен только для контейнеров, которые удовлетворяют требованиям Transformable.

3. Метод slice_and_transform(const Container &c, Func f):
Сначала к контейнеру применяется transform, затем результат фильтруется через slice. В результате возвращается контейнер, содержащий только преобразованные элементы, соответствующие true в маске. Метод доступен только для контейнеров, которые удовлетворяют требованиям как Transformable, так и одной из версий slice.






